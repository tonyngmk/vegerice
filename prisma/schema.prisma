// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url = env("DATABASE_URL")
  relationMode = "prisma"
}

// Next-Auth required models
model User {
    // Fundamentally, 1 person maps to 1 user.
    user_id       String    @id @default(cuid())
    user_name     String
    user_email    String   @unique
    user_verified DateTime?
    accounts      Account[]
    shops         Shop[]

    @@unique([user_id])
    @@index([user_id])
}

model Account {
    // 1 User can however have many accounts, i.e. via multiple platforms like Google, Facebook, etc.
    account_id          String  @id @default(cuid())
    user_id             String
    type                String
    account_provider    String
    account_provider_id String
    refresh_token       String? // @db.Text
    access_token        String? // @db.Text
    expires_at          Int?
    token_type          String?
    scope               String?
    id_token            String? // @db.Text
    session_state       String?
    user                User    @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
    sessions            Session[]

    @@unique([user_id, account_id])
    @@index([account_id])
}

model Session {
    // An account can have multiple sessions, i.e. A user's Google account has 2 sessions, and Facebook account has 1 session today.
    session_id    String   @id @default(cuid())
    sessionToken  String   @unique
    user_id       String
    account_id    String
    expires       DateTime
    account       Account  @relation(fields: [user_id, account_id], references: [user_id, account_id], onDelete: Cascade)
    
    @@unique([session_id])
    @@index([session_id])
}

model VerificationToken {
    identifier String
    token      String   @unique
    expires    DateTime

    @@unique([identifier, token])
}

// Database design for Vegerice
model Market {
    // A market is synonymous with a place where people eat, i.e. a hawker centre / food court / eatery / food street, etc.
    market_id            String    @id @default(cuid())
    market_name          String
    market_email         String?   @unique
    market_image         String?
    market_block_house   String?
    market_street_name   String?
    market_unit_no       Int?
    market_postal_code   Int?
    market_coordinates     String?
    shops         Shop[]

    @@index([market_id])
}

model Shop {
    // A market can have 1 or multiple shops, i.e. 1 selling rice, another selling noodles, etc.
    // For rare standalone food shops, a 'Market' can be optional too.
    shop_id            String    @id @default(cuid())
    user_id            String
    market_id          String?
    shop_name          String
    shop_email         String?   @unique
    shop_image         String?
    shop_block_house   String?
    shop_street_name   String?
    shop_unit_no       Int?
    shop_postal_code   Int?
    shop_description   String?
    shop_category_l1   String
    shop_category_l2   String?
    shop_coordinates     String?
    is_halal           Boolean?
    user               User    @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
    market             Market?  @relation(fields: [market_id], references: [market_id], onDelete: Cascade)
    shop_items         ShopItem[]

    @@unique([user_id, shop_id])
    @@index([shop_id])
}

model ShopItem {
    // A shop can sell many items, and some items can be best sellers supporting the reputation of a store, while exist other poorer performing ones.
    item_id          String    @id @default(cuid())
    shop_id          String
    item_name        String
    item_category_l1 String
    item_category_l2 String?
    item_description String?
    item_image       String?
    item_price       Float?
    shop             Shop    @relation(fields: [shop_id], references: [shop_id], onDelete: Cascade)

    @@unique([item_id])
    @@index([item_id])
}
